<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <title>üêç Snake Game</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      touch-action: none;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
    }

    body {
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-family: 'Segoe UI', system-ui, sans-serif;
      color: #fff;
      overflow: hidden;
      padding: 10px;
    }

    .game-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 15px;
      max-width: 100%;
    }

    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      width: 100%;
      max-width: 400px;
      padding: 0 10px;
    }

    .score {
      font-size: 1.5rem;
      font-weight: bold;
      color: #7dd3fc;
    }

    .high-score {
      font-size: 1rem;
      color: #86efac;
    }

    #gameCanvas {
      border: 3px solid #7dd3fc;
      border-radius: 10px;
      background: #0d1117;
      box-shadow: 0 0 30px rgba(125, 211, 252, 0.3);
      max-width: 100%;
      max-height: 60vh;
    }

    .controls {
      display: none;
      grid-template-columns: repeat(3, 1fr);
      grid-template-rows: repeat(3, 1fr);
      gap: 5px;
      width: 180px;
      height: 180px;
      margin-top: 10px;
    }

    @media (pointer: coarse) {
      .controls {
        display: grid;
      }
    }

    .ctrl-btn {
      background: rgba(125, 211, 252, 0.2);
      border: 2px solid #7dd3fc;
      border-radius: 10px;
      color: #7dd3fc;
      font-size: 2rem;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.1s;
    }

    .ctrl-btn:active {
      background: rgba(125, 211, 252, 0.5);
      transform: scale(0.95);
    }

    .ctrl-btn.up { grid-column: 2; grid-row: 1; }
    .ctrl-btn.left { grid-column: 1; grid-row: 2; }
    .ctrl-btn.right { grid-column: 3; grid-row: 2; }
    .ctrl-btn.down { grid-column: 2; grid-row: 3; }

    .overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.85);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 20px;
      z-index: 100;
    }

    .overlay.hidden {
      display: none;
    }

    .overlay h1 {
      font-size: 2.5rem;
      color: #7dd3fc;
      text-align: center;
    }

    .overlay p {
      font-size: 1.2rem;
      color: #a1a1aa;
      text-align: center;
      max-width: 300px;
    }

    .overlay .final-score {
      font-size: 3rem;
      color: #86efac;
      font-weight: bold;
    }

    .btn {
      background: linear-gradient(135deg, #7dd3fc 0%, #86efac 100%);
      color: #0d1117;
      border: none;
      padding: 15px 40px;
      font-size: 1.3rem;
      font-weight: bold;
      border-radius: 30px;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
    }

    .btn:hover {
      transform: scale(1.05);
      box-shadow: 0 0 20px rgba(125, 211, 252, 0.5);
    }

    .btn:active {
      transform: scale(0.98);
    }

    .instructions {
      font-size: 0.9rem;
      color: #71717a;
      text-align: center;
      margin-top: 10px;
    }

    @media (max-width: 400px) {
      .overlay h1 {
        font-size: 2rem;
      }
      .score {
        font-size: 1.2rem;
      }
    }
  </style>
</head>
<body>
  <div class="game-container">
    <div class="header">
      <div class="score">üçé <span id="score">0</span></div>
      <div class="high-score">üèÜ <span id="highScore">0</span></div>
    </div>
    
    <canvas id="gameCanvas"></canvas>
    
    <div class="controls">
      <div class="ctrl-btn up" data-dir="up">‚ñ≤</div>
      <div class="ctrl-btn left" data-dir="left">‚óÄ</div>
      <div class="ctrl-btn right" data-dir="right">‚ñ∂</div>
      <div class="ctrl-btn down" data-dir="down">‚ñº</div>
    </div>
    
    <p class="instructions" id="instructions">Use as setas ou deslize para jogar</p>
  </div>

  <div class="overlay" id="startOverlay">
    <h1>üêç Snake Game</h1>
    <p>Coma as ma√ß√£s e cres√ßa! N√£o bata nas paredes ou em voc√™ mesmo.</p>
    <button class="btn" id="startBtn">Jogar</button>
  </div>

  <div class="overlay hidden" id="gameOverOverlay">
    <h1>üíÄ Game Over</h1>
    <div class="final-score" id="finalScore">0</div>
    <p id="gameOverMsg">Tente novamente!</p>
    <button class="btn" id="restartBtn">Jogar de Novo</button>
  </div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    // Responsive canvas sizing
    function resizeCanvas() {
      const maxSize = Math.min(window.innerWidth - 20, window.innerHeight * 0.55, 400);
      canvas.width = maxSize;
      canvas.height = maxSize;
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // Game settings
    const gridSize = 20;
    let tileCount;
    let snake = [];
    let food = {};
    let dx = 0;
    let dy = 0;
    let score = 0;
    let highScore = parseInt(localStorage.getItem('snakeHighScore')) || 0;
    let gameLoop;
    let gameSpeed = 150;
    let isPlaying = false;

    // DOM elements
    const scoreEl = document.getElementById('score');
    const highScoreEl = document.getElementById('highScore');
    const startOverlay = document.getElementById('startOverlay');
    const gameOverOverlay = document.getElementById('gameOverOverlay');
    const finalScoreEl = document.getElementById('finalScore');
    const gameOverMsg = document.getElementById('gameOverMsg');

    highScoreEl.textContent = highScore;

    function initGame() {
      tileCount = Math.floor(canvas.width / gridSize);
      snake = [
        { x: Math.floor(tileCount / 2), y: Math.floor(tileCount / 2) }
      ];
      dx = 0;
      dy = 0;
      score = 0;
      scoreEl.textContent = score;
      gameSpeed = 150;
      placeFood();
    }

    function placeFood() {
      food = {
        x: Math.floor(Math.random() * tileCount),
        y: Math.floor(Math.random() * tileCount)
      };
      // Make sure food doesn't spawn on snake
      for (let segment of snake) {
        if (segment.x === food.x && segment.y === food.y) {
          placeFood();
          return;
        }
      }
    }

    function draw() {
      // Clear canvas
      ctx.fillStyle = '#0d1117';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Draw grid (subtle)
      ctx.strokeStyle = 'rgba(125, 211, 252, 0.1)';
      ctx.lineWidth = 0.5;
      for (let i = 0; i <= tileCount; i++) {
        ctx.beginPath();
        ctx.moveTo(i * gridSize, 0);
        ctx.lineTo(i * gridSize, canvas.height);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(0, i * gridSize);
        ctx.lineTo(canvas.width, i * gridSize);
        ctx.stroke();
      }

      // Draw food
      const foodX = food.x * gridSize;
      const foodY = food.y * gridSize;
      ctx.fillStyle = '#ef4444';
      ctx.beginPath();
      ctx.arc(foodX + gridSize/2, foodY + gridSize/2, gridSize/2 - 2, 0, Math.PI * 2);
      ctx.fill();
      // Apple shine
      ctx.fillStyle = 'rgba(255,255,255,0.3)';
      ctx.beginPath();
      ctx.arc(foodX + gridSize/2 - 3, foodY + gridSize/2 - 3, 3, 0, Math.PI * 2);
      ctx.fill();

      // Draw snake
      snake.forEach((segment, index) => {
        const x = segment.x * gridSize;
        const y = segment.y * gridSize;
        
        // Gradient from head to tail
        const gradient = ctx.createLinearGradient(x, y, x + gridSize, y + gridSize);
        if (index === 0) {
          gradient.addColorStop(0, '#86efac');
          gradient.addColorStop(1, '#22c55e');
        } else {
          const alpha = 1 - (index / snake.length) * 0.5;
          ctx.fillStyle = `rgba(34, 197, 94, ${alpha})`;
        }
        
        if (index === 0) {
          ctx.fillStyle = gradient;
        }
        
        // Rounded rectangle for segments
        const radius = 4;
        const padding = 1;
        ctx.beginPath();
        ctx.roundRect(x + padding, y + padding, gridSize - padding*2, gridSize - padding*2, radius);
        ctx.fill();

        // Eyes on head
        if (index === 0) {
          ctx.fillStyle = '#0d1117';
          const eyeSize = 3;
          const eyeOffset = 5;
          if (dx === 1) { // Right
            ctx.beginPath();
            ctx.arc(x + gridSize - eyeOffset, y + eyeOffset, eyeSize, 0, Math.PI * 2);
            ctx.arc(x + gridSize - eyeOffset, y + gridSize - eyeOffset, eyeSize, 0, Math.PI * 2);
            ctx.fill();
          } else if (dx === -1) { // Left
            ctx.beginPath();
            ctx.arc(x + eyeOffset, y + eyeOffset, eyeSize, 0, Math.PI * 2);
            ctx.arc(x + eyeOffset, y + gridSize - eyeOffset, eyeSize, 0, Math.PI * 2);
            ctx.fill();
          } else if (dy === -1) { // Up
            ctx.beginPath();
            ctx.arc(x + eyeOffset, y + eyeOffset, eyeSize, 0, Math.PI * 2);
            ctx.arc(x + gridSize - eyeOffset, y + eyeOffset, eyeSize, 0, Math.PI * 2);
            ctx.fill();
          } else { // Down or stationary
            ctx.beginPath();
            ctx.arc(x + eyeOffset, y + gridSize - eyeOffset, eyeSize, 0, Math.PI * 2);
            ctx.arc(x + gridSize - eyeOffset, y + gridSize - eyeOffset, eyeSize, 0, Math.PI * 2);
            ctx.fill();
          }
        }
      });
    }

    function update() {
      if (dx === 0 && dy === 0) {
        draw();
        return;
      }

      const head = { x: snake[0].x + dx, y: snake[0].y + dy };

      // Wall collision
      if (head.x < 0 || head.x >= tileCount || head.y < 0 || head.y >= tileCount) {
        gameOver();
        return;
      }

      // Self collision
      for (let segment of snake) {
        if (head.x === segment.x && head.y === segment.y) {
          gameOver();
          return;
        }
      }

      snake.unshift(head);

      // Food collision
      if (head.x === food.x && head.y === food.y) {
        score += 10;
        scoreEl.textContent = score;
        placeFood();
        // Speed up slightly
        if (gameSpeed > 80) {
          gameSpeed -= 2;
          clearInterval(gameLoop);
          gameLoop = setInterval(update, gameSpeed);
        }
      } else {
        snake.pop();
      }

      draw();
    }

    function gameOver() {
      isPlaying = false;
      clearInterval(gameLoop);
      
      if (score > highScore) {
        highScore = score;
        localStorage.setItem('snakeHighScore', highScore);
        highScoreEl.textContent = highScore;
        gameOverMsg.textContent = 'üéâ Novo recorde!';
      } else {
        gameOverMsg.textContent = 'Tente novamente!';
      }
      
      finalScoreEl.textContent = score;
      gameOverOverlay.classList.remove('hidden');
    }

    function startGame() {
      startOverlay.classList.add('hidden');
      gameOverOverlay.classList.add('hidden');
      initGame();
      isPlaying = true;
      draw();
      gameLoop = setInterval(update, gameSpeed);
    }

    // Keyboard controls
    document.addEventListener('keydown', (e) => {
      if (!isPlaying) return;
      
      switch(e.key) {
        case 'ArrowUp':
        case 'w':
        case 'W':
          if (dy !== 1) { dx = 0; dy = -1; }
          break;
        case 'ArrowDown':
        case 's':
        case 'S':
          if (dy !== -1) { dx = 0; dy = 1; }
          break;
        case 'ArrowLeft':
        case 'a':
        case 'A':
          if (dx !== 1) { dx = -1; dy = 0; }
          break;
        case 'ArrowRight':
        case 'd':
        case 'D':
          if (dx !== -1) { dx = 1; dy = 0; }
          break;
      }
    });

    // Touch controls (swipe)
    let touchStartX = 0;
    let touchStartY = 0;

    canvas.addEventListener('touchstart', (e) => {
      touchStartX = e.touches[0].clientX;
      touchStartY = e.touches[0].clientY;
    }, { passive: true });

    canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
    }, { passive: false });

    canvas.addEventListener('touchend', (e) => {
      if (!isPlaying) return;
      
      const touchEndX = e.changedTouches[0].clientX;
      const touchEndY = e.changedTouches[0].clientY;
      
      const diffX = touchEndX - touchStartX;
      const diffY = touchEndY - touchStartY;
      
      const minSwipe = 30;
      
      if (Math.abs(diffX) > Math.abs(diffY)) {
        if (diffX > minSwipe && dx !== -1) { dx = 1; dy = 0; }
        else if (diffX < -minSwipe && dx !== 1) { dx = -1; dy = 0; }
      } else {
        if (diffY > minSwipe && dy !== -1) { dx = 0; dy = 1; }
        else if (diffY < -minSwipe && dy !== 1) { dx = 0; dy = -1; }
      }
    }, { passive: true });

    // Button controls
    document.querySelectorAll('.ctrl-btn').forEach(btn => {
      btn.addEventListener('touchstart', (e) => {
        e.preventDefault();
        if (!isPlaying) return;
        
        const dir = btn.dataset.dir;
        switch(dir) {
          case 'up': if (dy !== 1) { dx = 0; dy = -1; } break;
          case 'down': if (dy !== -1) { dx = 0; dy = 1; } break;
          case 'left': if (dx !== 1) { dx = -1; dy = 0; } break;
          case 'right': if (dx !== -1) { dx = 1; dy = 0; } break;
        }
      }, { passive: false });
      
      btn.addEventListener('click', (e) => {
        if (!isPlaying) return;
        
        const dir = btn.dataset.dir;
        switch(dir) {
          case 'up': if (dy !== 1) { dx = 0; dy = -1; } break;
          case 'down': if (dy !== -1) { dx = 0; dy = 1; } break;
          case 'left': if (dx !== 1) { dx = -1; dy = 0; } break;
          case 'right': if (dx !== -1) { dx = 1; dy = 0; } break;
        }
      });
    });

    // Start/Restart buttons
    document.getElementById('startBtn').addEventListener('click', startGame);
    document.getElementById('restartBtn').addEventListener('click', startGame);

    // Initial draw
    initGame();
    draw();
  </script>
</body>
</html>
