<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="theme-color" content="#0d1117">
  <title>üêç Snake Game - Para Roberta üíö</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      touch-action: none;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
    }

    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      position: fixed;
      background: #0d1117;
    }

    body {
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-family: 'Segoe UI', system-ui, sans-serif;
      color: #fff;
    }

    .game-container {
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: space-between;
      padding: env(safe-area-inset-top, 10px) 10px env(safe-area-inset-bottom, 10px) 10px;
    }

    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      width: 100%;
      padding: 10px 20px;
      z-index: 10;
    }

    .score {
      font-size: 1.5rem;
      font-weight: bold;
      color: #7dd3fc;
    }

    .high-score {
      font-size: 1.2rem;
      color: #86efac;
    }

    #gameCanvas {
      border-radius: 10px;
      background: #0d1117;
      flex: 1;
      max-height: calc(100% - 80px);
      aspect-ratio: 1;
    }

    .swipe-hint {
      font-size: 0.9rem;
      color: #71717a;
      padding: 10px;
      text-align: center;
    }

    .overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.92);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 20px;
      z-index: 100;
      padding: 20px;
      padding-top: env(safe-area-inset-top, 20px);
      padding-bottom: env(safe-area-inset-bottom, 20px);
    }

    .overlay.hidden {
      display: none;
    }

    .overlay h1 {
      font-size: 3rem;
      color: #7dd3fc;
      text-align: center;
    }

    .overlay p {
      font-size: 1.2rem;
      color: #a1a1aa;
      text-align: center;
      max-width: 300px;
    }

    .overlay .dedication {
      font-size: 1.8rem;
      color: #86efac;
      font-weight: bold;
      margin-bottom: 10px;
    }

    .overlay .love-note {
      font-size: 1.1rem;
      color: #f472b6;
      margin-top: 20px;
      font-style: italic;
    }

    .overlay .final-score {
      font-size: 4rem;
      color: #86efac;
      font-weight: bold;
    }

    .btn {
      background: linear-gradient(135deg, #7dd3fc 0%, #86efac 100%);
      color: #0d1117;
      border: none;
      padding: 18px 50px;
      font-size: 1.5rem;
      font-weight: bold;
      border-radius: 30px;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
      margin-top: 10px;
    }

    .btn:active {
      transform: scale(0.95);
      box-shadow: 0 0 30px rgba(125, 211, 252, 0.6);
    }

    .instructions {
      font-size: 1rem;
      color: #71717a;
      text-align: center;
      margin-top: 15px;
    }
  </style>
</head>
<body>
  <div class="game-container">
    <div class="header">
      <div class="score">üçé <span id="score">0</span></div>
      <div class="high-score">üèÜ <span id="highScore">0</span></div>
    </div>
    
    <canvas id="gameCanvas"></canvas>
    
    <p class="swipe-hint">Deslize para mover üëÜ</p>
  </div>

  <div class="overlay" id="startOverlay">
    <h1>üêç Snake</h1>
    <p class="dedication">üíö Para Roberta üíö</p>
    <p>Coma as ma√ß√£s e cres√ßa!<br>N√£o bata nas paredes ou em voc√™ mesma.</p>
    <button class="btn" id="startBtn">Jogar</button>
    <p class="love-note">Com amor, Lucas ü•∞</p>
  </div>

  <div class="overlay hidden" id="gameOverOverlay">
    <h1>üíÄ Game Over</h1>
    <div class="final-score" id="finalScore">0</div>
    <p id="gameOverMsg">Tente novamente!</p>
    <button class="btn" id="restartBtn">Jogar de Novo</button>
  </div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    // Fullscreen canvas sizing
    function resizeCanvas() {
      const container = document.querySelector('.game-container');
      const header = document.querySelector('.header');
      const hint = document.querySelector('.swipe-hint');
      
      const availableHeight = window.innerHeight - header.offsetHeight - hint.offsetHeight - 40;
      const availableWidth = window.innerWidth - 20;
      const size = Math.min(availableWidth, availableHeight);
      
      canvas.width = size;
      canvas.height = size;
      canvas.style.width = size + 'px';
      canvas.style.height = size + 'px';
    }
    
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    window.addEventListener('orientationchange', () => setTimeout(resizeCanvas, 100));

    // Game settings
    const gridSize = 20;
    let tileCount;
    let snake = [];
    let food = {};
    let dx = 0;
    let dy = 0;
    let score = 0;
    let highScore = parseInt(localStorage.getItem('snakeHighScore_roberta')) || 0;
    let gameLoop;
    let gameSpeed = 140;
    let isPlaying = false;

    // DOM elements
    const scoreEl = document.getElementById('score');
    const highScoreEl = document.getElementById('highScore');
    const startOverlay = document.getElementById('startOverlay');
    const gameOverOverlay = document.getElementById('gameOverOverlay');
    const finalScoreEl = document.getElementById('finalScore');
    const gameOverMsg = document.getElementById('gameOverMsg');

    highScoreEl.textContent = highScore;

    function initGame() {
      tileCount = Math.floor(canvas.width / gridSize);
      snake = [
        { x: Math.floor(tileCount / 2), y: Math.floor(tileCount / 2) }
      ];
      dx = 0;
      dy = 0;
      score = 0;
      scoreEl.textContent = score;
      gameSpeed = 140;
      placeFood();
    }

    function placeFood() {
      food = {
        x: Math.floor(Math.random() * tileCount),
        y: Math.floor(Math.random() * tileCount)
      };
      for (let segment of snake) {
        if (segment.x === food.x && segment.y === food.y) {
          placeFood();
          return;
        }
      }
    }

    function draw() {
      const tileSize = canvas.width / tileCount;
      
      // Clear canvas
      ctx.fillStyle = '#0d1117';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Draw grid (subtle)
      ctx.strokeStyle = 'rgba(125, 211, 252, 0.08)';
      ctx.lineWidth = 0.5;
      for (let i = 0; i <= tileCount; i++) {
        ctx.beginPath();
        ctx.moveTo(i * tileSize, 0);
        ctx.lineTo(i * tileSize, canvas.height);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(0, i * tileSize);
        ctx.lineTo(canvas.width, i * tileSize);
        ctx.stroke();
      }

      // Draw food (apple with heart shape for Roberta)
      const foodX = food.x * tileSize;
      const foodY = food.y * tileSize;
      ctx.fillStyle = '#ef4444';
      ctx.beginPath();
      ctx.arc(foodX + tileSize/2, foodY + tileSize/2, tileSize/2 - 2, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = 'rgba(255,255,255,0.3)';
      ctx.beginPath();
      ctx.arc(foodX + tileSize/2 - 3, foodY + tileSize/2 - 3, 4, 0, Math.PI * 2);
      ctx.fill();

      // Draw snake
      snake.forEach((segment, index) => {
        const x = segment.x * tileSize;
        const y = segment.y * tileSize;
        
        if (index === 0) {
          const gradient = ctx.createLinearGradient(x, y, x + tileSize, y + tileSize);
          gradient.addColorStop(0, '#86efac');
          gradient.addColorStop(1, '#22c55e');
          ctx.fillStyle = gradient;
        } else {
          const alpha = 1 - (index / snake.length) * 0.5;
          ctx.fillStyle = `rgba(34, 197, 94, ${alpha})`;
        }
        
        const radius = 5;
        const padding = 1;
        ctx.beginPath();
        ctx.roundRect(x + padding, y + padding, tileSize - padding*2, tileSize - padding*2, radius);
        ctx.fill();

        // Eyes on head
        if (index === 0) {
          ctx.fillStyle = '#0d1117';
          const eyeSize = Math.max(3, tileSize / 6);
          const eyeOffset = tileSize / 4;
          if (dx === 1) {
            ctx.beginPath();
            ctx.arc(x + tileSize - eyeOffset, y + eyeOffset, eyeSize, 0, Math.PI * 2);
            ctx.arc(x + tileSize - eyeOffset, y + tileSize - eyeOffset, eyeSize, 0, Math.PI * 2);
            ctx.fill();
          } else if (dx === -1) {
            ctx.beginPath();
            ctx.arc(x + eyeOffset, y + eyeOffset, eyeSize, 0, Math.PI * 2);
            ctx.arc(x + eyeOffset, y + tileSize - eyeOffset, eyeSize, 0, Math.PI * 2);
            ctx.fill();
          } else if (dy === -1) {
            ctx.beginPath();
            ctx.arc(x + eyeOffset, y + eyeOffset, eyeSize, 0, Math.PI * 2);
            ctx.arc(x + tileSize - eyeOffset, y + eyeOffset, eyeSize, 0, Math.PI * 2);
            ctx.fill();
          } else {
            ctx.beginPath();
            ctx.arc(x + eyeOffset, y + tileSize - eyeOffset, eyeSize, 0, Math.PI * 2);
            ctx.arc(x + tileSize - eyeOffset, y + tileSize - eyeOffset, eyeSize, 0, Math.PI * 2);
            ctx.fill();
          }
        }
      });
    }

    function update() {
      if (dx === 0 && dy === 0) {
        draw();
        return;
      }

      const head = { x: snake[0].x + dx, y: snake[0].y + dy };

      if (head.x < 0 || head.x >= tileCount || head.y < 0 || head.y >= tileCount) {
        gameOver();
        return;
      }

      for (let segment of snake) {
        if (head.x === segment.x && head.y === segment.y) {
          gameOver();
          return;
        }
      }

      snake.unshift(head);

      if (head.x === food.x && head.y === food.y) {
        score += 10;
        scoreEl.textContent = score;
        placeFood();
        if (gameSpeed > 70) {
          gameSpeed -= 2;
          clearInterval(gameLoop);
          gameLoop = setInterval(update, gameSpeed);
        }
      } else {
        snake.pop();
      }

      draw();
    }

    function gameOver() {
      isPlaying = false;
      clearInterval(gameLoop);
      
      if (score > highScore) {
        highScore = score;
        localStorage.setItem('snakeHighScore_roberta', highScore);
        highScoreEl.textContent = highScore;
        gameOverMsg.textContent = 'üéâ Novo recorde, amor!';
      } else {
        gameOverMsg.textContent = 'Tenta de novo, R√¥! üí™';
      }
      
      finalScoreEl.textContent = score;
      gameOverOverlay.classList.remove('hidden');
    }

    function startGame() {
      startOverlay.classList.add('hidden');
      gameOverOverlay.classList.add('hidden');
      resizeCanvas();
      initGame();
      isPlaying = true;
      draw();
      gameLoop = setInterval(update, gameSpeed);
    }

    // Touch controls (swipe only)
    let touchStartX = 0;
    let touchStartY = 0;
    let touchStartTime = 0;

    document.addEventListener('touchstart', (e) => {
      if (!isPlaying) return;
      touchStartX = e.touches[0].clientX;
      touchStartY = e.touches[0].clientY;
      touchStartTime = Date.now();
    }, { passive: true });

    document.addEventListener('touchmove', (e) => {
      e.preventDefault();
    }, { passive: false });

    document.addEventListener('touchend', (e) => {
      if (!isPlaying) return;
      
      const touchEndX = e.changedTouches[0].clientX;
      const touchEndY = e.changedTouches[0].clientY;
      const touchTime = Date.now() - touchStartTime;
      
      const diffX = touchEndX - touchStartX;
      const diffY = touchEndY - touchStartY;
      
      const minSwipe = 20;
      
      // Quick swipe detection
      if (touchTime < 300 || Math.abs(diffX) > minSwipe || Math.abs(diffY) > minSwipe) {
        if (Math.abs(diffX) > Math.abs(diffY)) {
          if (diffX > minSwipe && dx !== -1) { dx = 1; dy = 0; }
          else if (diffX < -minSwipe && dx !== 1) { dx = -1; dy = 0; }
        } else {
          if (diffY > minSwipe && dy !== -1) { dx = 0; dy = 1; }
          else if (diffY < -minSwipe && dy !== 1) { dx = 0; dy = -1; }
        }
      }
    }, { passive: true });

    // Prevent zoom
    document.addEventListener('gesturestart', (e) => e.preventDefault());
    document.addEventListener('gesturechange', (e) => e.preventDefault());

    // Start/Restart buttons
    document.getElementById('startBtn').addEventListener('click', startGame);
    document.getElementById('restartBtn').addEventListener('click', startGame);

    // Initial draw
    initGame();
    draw();
  </script>
</body>
</html>
